[{"title":"自定义懒加载指令+三种滚动加载效果","url":"/2025/07/08/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%87%92%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4-%E4%B8%89%E7%A7%8D%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%95%88%E6%9E%9C/","content":"\n传统 scroll 事件\nscroll 事件 + 节流 + requestAnimationFrame 优化\nIntersectionObserver 观察者模式\n自定义懒加载指令\n\n\n\n三种滚动加载效果传统 scroll 事件\n原理：监听页面滚动事件，分析 clientHeight,scrollTop,scrollHeight 关系\n\nscrollTop – 滚动条距离顶部的高度\n\n\n\nscrollHeight – 当前页面的总高度(body 总高度)\n\n\n\nclientHeight – 当前可视的页面高度(设备窗口的高度)\n\n\n\nwindow.addEventListener(  &quot;scroll&quot;,  function () &#123;    // 获取视口的高度。window.innerHeight || Math.min(document.documentElement.clientHeight, document.body.clientHeight);    const clientHeight = document.documentElement.clientHeight;    // 获取滚动条的垂直位置。window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;    const scrollTop = document.documentElement.scrollTop;    // 获取文档的总高度。Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);    const scrollHeight = document.documentElement.scrollHeight;    // 检查是否滚动到底部    if (clientHeight + scrollTop &gt;= scrollHeight) &#123;      // 监测到滚动到底部，进行后续操作    &#125;  &#125;,  false);\n\nscroll 事件 + 节流 + requestAnimationFrame 优化\n在传统的滚动监听中，每次滚动都会触发 scroll 事件，可能会导致性能问题。为了解决这个问题，我们可以使用节流（throttle）来限制触发频率。\n使用 requestAnimationFrame 浏览器会自动优化动画，从而提高性能。\n\nlet isScrolling = false;window.addEventListener(&quot;scroll&quot;, () =&gt; &#123;  if (!isScrolling) &#123;    isScrolling = true;    requestAnimationFrame(function () &#123;      const clientHeight = document.documentElement.clientHeight;      const scrollTop = document.documentElement.scrollTop;      const scrollHeight = document.documentElement.scrollHeight;      if (clientHeight + scrollTop &gt;= scrollHeight) &#123;        console.log(&quot;滚动到底部了，可以加载更多内容&quot;);        // 在这里调用加载更多内容的函数      &#125;      isScrolling = false;    &#125;);  &#125;&#125;);\n\nIntersectionObserver 观察者模式\nIntersectionObserver 是一种用于监听元素是否进入或离开可视区域的 API，它可以实现懒加载。\n\nfunction handleIntersection(entries, observer) &#123;  entries.forEach((entry) =&gt; &#123;    if (entry.isIntersecting) &#123;      loadMoreData().then((newData) =&gt; &#123;        console.log(&quot;loadMoreData:&quot;, newData);        // 重新观察加载提示        observer.observe(document.getElementById(&quot;loader&quot;));      &#125;);    &#125;  &#125;);&#125;const observer = new IntersectionObserver(handleIntersection, &#123;  threshold: 0.1, // 当加载提示进入视口 10% 时触发&#125;);// 开始观察加载提示observer.observe(document.getElementById(&quot;loader&quot;));\n\n自定义懒加载指令定义了一个自定义指令 v-lazy，用于懒加载图片。\n// 自定义指令，懒加载app.directive(&quot;lazy&quot;, &#123;  mounted(el, binding) &#123;    const observe = new IntersectionObserver(      ([&#123; isIntersecting &#125;]) =&gt; &#123;        if (isIntersecting) &#123;          observe.unobserve(el);          el.onerror = () =&gt; &#123;            el.src = defaultImg;          &#125;;          el.src = binding.value;        &#125;      &#125;,      &#123;        threshold: 0,      &#125;    );    observe.observe(el);  &#125;,&#125;);\n"},{"title":"URL路径解析","url":"/2025/07/08/URL%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90/","content":"解析 URL 参数为对象 parseParam\n\n\n实现原理\n使用new URL()或者window.location.hash获取到 URL 对象。\nnew URLSearchParams() 创建一个参数对象。\n最后使用 for...of 循环遍历参数对象，将参数名和参数值组成对象并返回。\n\n代码实现核心逻辑const parseParam = (url) =&gt; &#123;  const urlObj = new URL(url);  const params = new URLSearchParams(urlObj.search);  const paramObj = &#123;&#125;;  for (const [key, value] of params) &#123;    paramObj[key] = value;  &#125;  return paramObj;&#125;;parseParam(&quot;https://www.example.com?name=John&amp;age=30&quot;);// 输出：&#123; name: &#x27;John&#x27;, age: &#x27;30&#x27; &#125;\n\n对代码进行优化，优化只有一个参数的情况、添加判断条件、数字类型判断。\n优化完整代码/** * @param &#123;*&#125; url * @returns */function parseParam(url) &#123;  const urlObj = new URL(url);  const queryParams = new URLSearchParams(urlObj.search);  const paramsObj = &#123;&#125;;  for (let [key, value] of queryParams.entries()) &#123;    if (value === &quot;&quot;) &#123;      paramsObj[key] = true;    &#125; else &#123;      let val = decodeURIComponent(value);      val = /^\\d+$/.test(val) ? parseFloat(val) : val;      if (paramsObj.hasOwnProperty(key)) &#123;        paramsObj[key] = [].concat(paramsObj[key], val);      &#125; else &#123;        paramsObj[key] = val;      &#125;    &#125;  &#125;  return paramsObj;&#125;\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"打字机效果实现","url":"/2025/07/03/%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/","content":"打字机效果是一种常见的网页动画效果，通常用于在页面上逐字显示文字内容，模拟真实的打字过程。本文将实现一个简单的打字机效果。\n\n\n实现原理\n定义一个 initTypewriter() 方法，用于初始化打字机效果。\nquerySelector(&#39;.description&#39;) 获取整个描述框；\n初始设置为透明 (opacity: 0 )，然后通过 setTimeout 延迟显示；\n使用 .desc-item 容器包裹每一行文字；\n对每个 .desc-item 内容进行逐字拼接，并通过递归调用 typewriter() 函数实现逐字显示；\n.desc 表示实际显示的文字内容；\n当所有字符显示完毕后，隐藏光标 .cursor。\n\n代码实现JavaScript 逻辑&lt;script&gt;  const initTypewriter = () =&gt; &#123;    const descBox = document.querySelector(&#x27;.description&#x27;)    if (descBox) &#123;      descBox.style.opacity = &#x27;0&#x27;      setTimeout(() =&gt; &#123;        descBox.style.opacity = &#x27;1&#x27;        const descItemList = descBox.querySelectorAll(&#x27;.desc-item&#x27;)        descItemList.forEach(descItem =&gt; &#123;          const desc = descItem.querySelector(&#x27;.desc&#x27;)          const cursor = descItem.querySelector(&#x27;.cursor&#x27;)          const text = desc.innerHTML          desc.innerHTML = &#x27;&#x27;          let charIndex = 0          const typewriter = () =&gt; &#123;            if (charIndex &lt; text.length) &#123;              desc.textContent += text[charIndex]              charIndex++              setTimeout(typewriter, 100)            &#125; else &#123;              cursor.style.display = &#x27;none&#x27;            &#125;          &#125;          if (text) typewriter()        &#125;)      &#125;, 300)    &#125;  &#125;  initTypewriter()&lt;/script&gt;\n\nHTML 结构&lt;div class=&quot;description&quot;&gt;  &lt;div class=&quot;desc-item&quot;&gt;    &lt;span class=&quot;desc&quot;&gt;打印机打字效果展示~~~&lt;/span&gt;    &lt;span class=&quot;cursor&quot;&gt;｜&lt;/span&gt;  &lt;/div&gt;  &lt;div class=&quot;desc-item&quot;&gt;    &lt;span class=&quot;desc&quot;&gt;学习新思想，争做新青年！&lt;/span&gt;    &lt;span class=&quot;cursor&quot;&gt;｜&lt;/span&gt;  &lt;/div&gt;&lt;/div&gt;\n\n可选 CSS 样式（增强视觉效果）.description &#123;  font-size: 20px;  line-height: 1.5;&#125;.desc-item &#123;  margin-bottom: 1em;&#125;\n","categories":["前端展示"],"tags":["娱乐"]},{"title":"第二篇文章","url":"/2025/07/01/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/","content":"大家好，我是lizheng\n","tags":["生活","自己"]},{"title":"文章1","url":"/2025/07/01/%E6%96%87%E7%AB%A01/","content":"这是我的第一篇博客文章。\n","categories":["技术"],"tags":["博客","测试"]},{"title":"Hello World","url":"/2025/07/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]