[{"title":"js操作文件","url":"/2025/07/24/js%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/","content":"一个 Node.js 环境配置脚本，实现一些简单的文件操作，环境切换，日志颜色切换\n\njs操作文件1. 实现的简单功能\n启动脚本并传入环境参数\n读取指定环境的配置文件，将配置写入通用配置文件 .env.json\n获取文件路径\n执行文件系统管理操作\n输出彩色日志信息\n\n2. 功能实现代码展示2.1  启动脚本并传入环境参数在 命令行 执行 node ./magic-env.js sit ,sit 为环境参数\n// 打印日志console.log(&#x27;111111&#x27;);// 获取环境变量const argv = require(&#x27;process&#x27;).argv;console.log(argv, &#x27;argv&#x27;);let env = argv[argv.length - 1];console.log(env, &#x27;env&#x27;);\n\n2.2 环境变量处理\n通过 process.argv 获取命令行参数中的环境标识\n读取对应环境的配置文件 .env-$&#123;env&#125;.json\n将读取的配置写入到 .env.json 文件中，实现环境切换\n\n// 文件替换，读取修改const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const data = fs.readFileSync(  path.resolve(__dirname, `./.env-$&#123;env&#125;.json`),  &#x27;utf-8&#x27;);fs.writeFileSync(path.resolve(__dirname, &#x27;./.env.json&#x27;), data, &#x27;utf-8&#x27;);console.log(&#x27;环境变量写入成功&#x27;, data);\n\n2.3 文件路径操作\n使用 path.join 和 path.resolve 构建文件路径\n示例中构建了 src/common/util/crypto.js 和 .env.json 的路径\n\n// 获取文件路径  __dirname为当前文件所在目录const ADir = path.join(  __dirname,  &#x27;src&#x27;,  &#x27;common&#x27;,  &#x27;util&#x27;,  &#x27;crypto.js&#x27;);const BDir = path.join(  __dirname,  &#x27;.env.json&#x27;);console.log(__dirname, ADir, BDir);\n\n2.4 文件夹递归删除\n实现了 deleteFolderRecursive 函数用于递归删除文件夹\n遍历文件夹内所有文件和子文件夹，逐一删除后删除根文件夹\n当前配置删除 aaa 文件夹\n\n// 删除文件夹的方法const deleteFolderRecursive = function (path) &#123;  var files = [];  if (fs.existsSync(path)) &#123;    files = fs.readdirSync(path);    files.forEach(function (file, index) &#123;      var curPath = path + &quot;/&quot; + file;      if (fs.statSync(curPath).isDirectory()) &#123;        deleteFolderRecursive(curPath);      &#125; else &#123;        fs.unlinkSync(curPath);      &#125;    &#125;)    fs.rmdirSync(path);  &#125;&#125;const deleteDir = path.join(  __dirname,  &#x27;aaa&#x27;);deleteFolderRecursive(deleteDir);\n\n2.5 控制台彩色输出\n定义了 colors 对象，包含各种 ANSI 颜色代码\n可以实现控制台文本的彩色显示，提升日志可读性\n示例中使用红色显示文本\n\n// 日志打印颜色const colors = &#123;  reset: &quot;\\x1b[0m&quot;,  bold: &quot;\\x1b[1m&quot;,  underline: &quot;\\x1b[4m&quot;,  black: &quot;\\x1b[30m&quot;,  red: &quot;\\x1b[31m&quot;,  green: &quot;\\x1b[32m&quot;,  yellow: &quot;\\x1b[33m&quot;,  blue: &quot;\\x1b[34m&quot;,  magenta: &quot;\\x1b[35m&quot;,  cyan: &quot;\\x1b[36m&quot;,  white: &quot;\\x1b[37m&quot;,  bgBlack: &quot;\\x1b[40m&quot;,  bgRed: &quot;\\x1b[41m&quot;,  bgGreen: &quot;\\x1b[42m&quot;,  bgYellow: &quot;\\x1b[43m&quot;,  bgBlue: &quot;\\x1b[44m&quot;,  bgMagenta: &quot;\\x1b[45m&quot;,  bgCyan: &quot;\\x1b[46m&quot;,  bgWhite: &quot;\\x1b[47m&quot;&#125;;console.log(colors.red,`颜色变红`, &#x27;=====&gt;&#x27;, env + colors.reset)\n"},{"title":"自定义懒加载指令+三种滚动加载效果","url":"/2025/07/08/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%87%92%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4-%E4%B8%89%E7%A7%8D%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%95%88%E6%9E%9C/","content":"\n传统 scroll 事件\nscroll 事件 + 节流 + requestAnimationFrame 优化\nIntersectionObserver 观察者模式\n自定义懒加载指令\n\n\n\n三种滚动加载效果传统 scroll 事件\n原理：监听页面滚动事件，分析 clientHeight,scrollTop,scrollHeight 关系\n\nscrollTop – 滚动条距离顶部的高度\n\n\n\nscrollHeight – 当前页面的总高度(body 总高度)\n\n\n\nclientHeight – 当前可视的页面高度(设备窗口的高度)\n\n\n\nwindow.addEventListener(  &quot;scroll&quot;,  function () &#123;    // 获取视口的高度。window.innerHeight || Math.min(document.documentElement.clientHeight, document.body.clientHeight);    const clientHeight = document.documentElement.clientHeight;    // 获取滚动条的垂直位置。window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;    const scrollTop = document.documentElement.scrollTop;    // 获取文档的总高度。Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);    const scrollHeight = document.documentElement.scrollHeight;    // 检查是否滚动到底部    if (clientHeight + scrollTop &gt;= scrollHeight) &#123;      // 监测到滚动到底部，进行后续操作    &#125;  &#125;,  false);\n\nscroll 事件 + 节流 + requestAnimationFrame 优化\n在传统的滚动监听中，每次滚动都会触发 scroll 事件，可能会导致性能问题。为了解决这个问题，我们可以使用节流（throttle）来限制触发频率。\n使用 requestAnimationFrame 浏览器会自动优化动画，从而提高性能。\n\nlet isScrolling = false;window.addEventListener(&quot;scroll&quot;, () =&gt; &#123;  if (!isScrolling) &#123;    isScrolling = true;    requestAnimationFrame(function () &#123;      const clientHeight = document.documentElement.clientHeight;      const scrollTop = document.documentElement.scrollTop;      const scrollHeight = document.documentElement.scrollHeight;      if (clientHeight + scrollTop &gt;= scrollHeight) &#123;        console.log(&quot;滚动到底部了，可以加载更多内容&quot;);        // 在这里调用加载更多内容的函数      &#125;      isScrolling = false;    &#125;);  &#125;&#125;);\n\nIntersectionObserver 观察者模式\nIntersectionObserver 是一种用于监听元素是否进入或离开可视区域的 API，它可以实现懒加载。\n\nfunction handleIntersection(entries, observer) &#123;  entries.forEach((entry) =&gt; &#123;    if (entry.isIntersecting) &#123;      loadMoreData().then((newData) =&gt; &#123;        console.log(&quot;loadMoreData:&quot;, newData);        // 重新观察加载提示        observer.observe(document.getElementById(&quot;loader&quot;));      &#125;);    &#125;  &#125;);&#125;const observer = new IntersectionObserver(handleIntersection, &#123;  threshold: 0.1, // 当加载提示进入视口 10% 时触发&#125;);// 开始观察加载提示observer.observe(document.getElementById(&quot;loader&quot;));\n\n自定义懒加载指令定义了一个自定义指令 v-lazy，用于懒加载图片。\n// 自定义指令，懒加载app.directive(&quot;lazy&quot;, &#123;  mounted(el, binding) &#123;    const observe = new IntersectionObserver(      ([&#123; isIntersecting &#125;]) =&gt; &#123;        if (isIntersecting) &#123;          observe.unobserve(el);          el.onerror = () =&gt; &#123;            el.src = defaultImg;          &#125;;          el.src = binding.value;        &#125;      &#125;,      &#123;        threshold: 0,      &#125;    );    observe.observe(el);  &#125;,&#125;);\n","categories":["懒加载"],"tags":["懒加载"]},{"title":"URL路径解析","url":"/2025/07/08/URL%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90/","content":"解析 URL 参数为对象 parseParam\n\n\n实现原理\n使用new URL()或者window.location.hash获取到 URL 对象。\nnew URLSearchParams() 创建一个参数对象。\n最后使用 for...of 循环遍历参数对象，将参数名和参数值组成对象并返回。\n\n代码实现核心逻辑const parseParam = (url) =&gt; &#123;  const urlObj = new URL(url);  const params = new URLSearchParams(urlObj.search);  const paramObj = &#123;&#125;;  for (const [key, value] of params) &#123;    paramObj[key] = value;  &#125;  return paramObj;&#125;;parseParam(&quot;https://www.example.com?name=John&amp;age=30&quot;);// 输出：&#123; name: &#x27;John&#x27;, age: &#x27;30&#x27; &#125;\n\n对代码进行优化，优化只有一个参数的情况、添加判断条件、数字类型判断。\n优化完整代码/** * @param &#123;*&#125; url * @returns */function parseParam(url) &#123;  const urlObj = new URL(url);  const queryParams = new URLSearchParams(urlObj.search);  const paramsObj = &#123;&#125;;  for (let [key, value] of queryParams.entries()) &#123;    if (value === &quot;&quot;) &#123;      paramsObj[key] = true;    &#125; else &#123;      let val = decodeURIComponent(value);      val = /^\\d+$/.test(val) ? parseFloat(val) : val;      if (paramsObj.hasOwnProperty(key)) &#123;        paramsObj[key] = [].concat(paramsObj[key], val);      &#125; else &#123;        paramsObj[key] = val;      &#125;    &#125;  &#125;  return paramsObj;&#125;\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"打字机效果实现","url":"/2025/07/03/%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/","content":"打字机效果是一种常见的网页动画效果，通常用于在页面上逐字显示文字内容，模拟真实的打字过程。本文将实现一个简单的打字机效果。\n\n\n实现原理\n定义一个 initTypewriter() 方法，用于初始化打字机效果。\nquerySelector(&#39;.description&#39;) 获取整个描述框；\n初始设置为透明 (opacity: 0 )，然后通过 setTimeout 延迟显示；\n使用 .desc-item 容器包裹每一行文字；\n对每个 .desc-item 内容进行逐字拼接，并通过递归调用 typewriter() 函数实现逐字显示；\n.desc 表示实际显示的文字内容；\n当所有字符显示完毕后，隐藏光标 .cursor。\n\n代码实现JavaScript 逻辑&lt;script&gt;  const initTypewriter = () =&gt; &#123;    const descBox = document.querySelector(&#x27;.description&#x27;)    if (descBox) &#123;      descBox.style.opacity = &#x27;0&#x27;      setTimeout(() =&gt; &#123;        descBox.style.opacity = &#x27;1&#x27;        const descItemList = descBox.querySelectorAll(&#x27;.desc-item&#x27;)        descItemList.forEach(descItem =&gt; &#123;          const desc = descItem.querySelector(&#x27;.desc&#x27;)          const cursor = descItem.querySelector(&#x27;.cursor&#x27;)          const text = desc.innerHTML          desc.innerHTML = &#x27;&#x27;          let charIndex = 0          const typewriter = () =&gt; &#123;            if (charIndex &lt; text.length) &#123;              desc.textContent += text[charIndex]              charIndex++              setTimeout(typewriter, 100)            &#125; else &#123;              cursor.style.display = &#x27;none&#x27;            &#125;          &#125;          if (text) typewriter()        &#125;)      &#125;, 300)    &#125;  &#125;  initTypewriter()&lt;/script&gt;\n\nHTML 结构&lt;div class=&quot;description&quot;&gt;  &lt;div class=&quot;desc-item&quot;&gt;    &lt;span class=&quot;desc&quot;&gt;打印机打字效果展示~~~&lt;/span&gt;    &lt;span class=&quot;cursor&quot;&gt;｜&lt;/span&gt;  &lt;/div&gt;  &lt;div class=&quot;desc-item&quot;&gt;    &lt;span class=&quot;desc&quot;&gt;学习新思想，争做新青年！&lt;/span&gt;    &lt;span class=&quot;cursor&quot;&gt;｜&lt;/span&gt;  &lt;/div&gt;&lt;/div&gt;\n\n可选 CSS 样式（增强视觉效果）.description &#123;  font-size: 20px;  line-height: 1.5;&#125;.desc-item &#123;  margin-bottom: 1em;&#125;\n","categories":["前端展示"],"tags":["娱乐"]},{"title":"第二篇文章","url":"/2025/07/01/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/","content":"大家好，我是lizheng\n","tags":["生活","自己"]},{"title":"文章1","url":"/2025/07/01/%E6%96%87%E7%AB%A01/","content":"这是我的第一篇博客文章。\n","categories":["技术"],"tags":["博客","测试"]},{"title":"Hello World","url":"/2025/07/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]